BEGIN

// ============================
//        HEIGHT FUNCTION
// ============================
FUNCTION Height(node)
    IF node = NULL THEN
        RETURN 0
    END IF
    RETURN node.height
END FUNCTION


// ============================
//      BALANCE FACTOR
// ============================
FUNCTION GetBalance(node)
    IF node = NULL THEN
        RETURN 0
    END IF
    RETURN Height(node.left) - Height(node.right)
END FUNCTION



// ============================
//       RIGHT ROTATION
// ============================
FUNCTION RightRotate(y)

    x ← y.left
    T2 ← x.right

    // Rotate
    x.right ← y
    y.left ← T2

    // Update heights
    y.height ← 1 + max(Height(y.left), Height(y.right))
    x.height ← 1 + max(Height(x.left), Height(x.right))

    RETURN x   // New root
END FUNCTION



// ============================
//       LEFT ROTATION
// ============================
FUNCTION LeftRotate(x)

    y ← x.right
    T2 ← y.left

    // Rotate
    y.left ← x
    x.right ← T2

    // Update heights
    x.height ← 1 + max(Height(x.left), Height(x.right))
    y.height ← 1 + max(Height(y.left), Height(y.right))

    RETURN y   // New root
END FUNCTION



// ============================
//       AVL INSERTION
// ============================
FUNCTION AVLInsert(node, key)

    // 1. Normal BST insertion
    IF node = NULL THEN
        RETURN new Node(key)
    END IF

    IF key < node.key THEN
        node.left ← AVLInsert(node.left, key)
    ELSE IF key > node.key THEN
        node.right ← AVLInsert(node.right, key)
    ELSE
        RETURN node      // No duplicates allowed
    END IF


    // 2. Update height
    node.height ← 1 + max(Height(node.left), Height(node.right))


    // 3. Check balance
    balance ← GetBalance(node)


    // 4. Imbalance Cases

    // Left Left Case
    IF balance > 1 AND key < node.left.key THEN
        RETURN RightRotate(node)
    END IF

    // Right Right Case
    IF balance < -1 AND key > node.right.key THEN
        RETURN LeftRotate(node)
    END IF

    // Left Right Case
    IF balance > 1 AND key > node.left.key THEN
        node.left ← LeftRotate(node.left)
        RETURN RightRotate(node)
    END IF

    // Right Left Case
    IF balance < -1 AND key < node.right.key THEN
        node.right ← RightRotate(node.right)
        RETURN LeftRotate(node)
    END IF

    RETURN node
END FUNCTION



// ============================
//      INORDER TRAVERSAL
// ============================
FUNCTION Inorder(node)
    IF node ≠ NULL THEN
        Inorder(node.left)
        PRINT node.key
        Inorder(node.right)
    END IF
END FUNCTION



// ============================
//      PREORDER TRAVERSAL
// ============================
FUNCTION Preorder(node)
    IF node ≠ NULL THEN
        PRINT node.key
        Preorder(node.left)
        Preorder(node.right)
    END IF
END FUNCTION



// ============================
//      POSTORDER TRAVERSAL
// ============================
FUNCTION Postorder(node)
    IF node ≠ NULL THEN
        Postorder(node.left)
        Postorder(node.right)
        PRINT node.key
    END IF
END FUNCTION


END
